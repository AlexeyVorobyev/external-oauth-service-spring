import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

val graphqlValidationVersion: String by project
val graphqlVersion: String by project
val appVersion: String by project


plugins {
    id("org.springframework.boot") version "3.2.4"
    id("io.spring.dependency-management") version "1.1.4"
    kotlin("jvm") version "1.9.23"
    kotlin("plugin.spring") version "1.9.23"
    kotlin("plugin.jpa") version "1.9.23"
}

group = "org.lexxv"
version = "0.0.1-SNAPSHOT"

java {
    sourceCompatibility = JavaVersion.VERSION_21
}

repositories {
    mavenCentral()
}

dependencies {
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.jetbrains.kotlin:kotlin-reflect")

    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
    implementation("org.liquibase:liquibase-core")

    implementation("io.jsonwebtoken:jjwt-api:0.12.3")
    implementation("io.jsonwebtoken:jjwt-impl:0.12.3")
    implementation("io.jsonwebtoken:jjwt-jackson:0.12.3")
    implementation("org.springframework.boot:spring-boot-starter-security")

    implementation("com.graphql-java-kickstart:graphql-spring-boot-starter:$graphqlVersion")
    implementation("com.graphql-java:graphql-java-extended-validation:$graphqlValidationVersion")

    implementation("org.postgresql:postgresql")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.testcontainers:testcontainers")
    testImplementation("org.testcontainers:postgresql")
    testImplementation("org.springframework.security:spring-security-test")
}

allOpen {
    annotation("javax.persistence.Entity")
    annotation("javax.persistence.MappedSuperclass")
    annotation("javax.persistence.Embeddable")
}


tasks.withType<KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs += "-Xjsr305=strict"
        jvmTarget = "21"
    }
}

tasks.withType<Test> {
    useJUnitPlatform()
}

/**
 * `Gradle` задача объединения файлов GraphQL схем в один файл.
 *
 * Файлы схем разбиты по пространствам имён и сущностям в директории `src/main/resources/graphql`.
 */
abstract class CompileGraphQLSchema : DefaultTask() {
    @get:Input
    abstract val dir: Property<File>

    @get:Input
    abstract var appName: String

    @get:Input
    abstract var appVer: String

    @get:Input
    abstract var createdAt: String
    private var mode = MODE_PROD
    private var remTodo: Boolean? = null
    private val allowedModes = listOf(MODE_PROD, MODE_PRE, MODE_TEST)

    companion object {
        const val MODE_PROD = "prod"
        const val MODE_PRE = "pre"
        const val MODE_TEST = "test"
    }

    @Internal
    override fun getDescription(): String =
        "Compile GraphQL schema files into one `pre-schema.graphqls` or `schema.graphqls` file."

    @Option(
        option = "mode",
        description = "Set schema type: `pre` - for frontend developers, `prod` (default) - for production."
    )
    fun setMode(mode: String) {
        require(mode in allowedModes) { "Invalid mode `$mode`" }
        this.mode = mode
    }

    @Option(
        option = "remTodo",
        description = "Remove `<todo>` tags. Always `true` in `prod` mode. Defaults `false` in other modes."
    )
    fun setRemTodo(remTodo: Boolean) {
        this.remTodo = remTodo
    }

    @TaskAction
    open fun run() {
        println("Compiling schema for `$mode` mode...")
        setRemTodo()
        val schema = getSchemaFile()
        concatFiles(schema, File(dir.get(), "graphql"))
        setMeta(schema)
    }

    private fun setRemTodo() {
        if (remTodo == null) {
            remTodo = mode == MODE_PROD
        }
    }

    @Suppress("MagicNumber")
    private fun setMeta(schema: File) {
        schema.writeText(
            schema.readText()
                .replace("{schemaName}", schema.name)
                .replace("{appName}", appName)
                .replace("{appVer}", appVer)
                .replace("{createdAt}", createdAt.take(19))
        )
    }

    private fun getSchemaFile(): File {
        val metaInfo = """
            #####################################################################
            # DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN #
            #####################################################################
            
        """.trimIndent()
        val prefix = if (mode != MODE_PROD) "$mode-" else ""
        val schema = File(dir.get(), "${prefix}schema.graphqls")
        schema.writeText("$metaInfo\n")
        return schema
    }

    private fun concatFiles(schemaFile: File, dir: File) {
        val dirPath = dir.canonicalPath
        dir.list()?.sorted()?.forEach {
            val file = File("$dirPath/$it")
            if (file.isDirectory) {
                if (file.name != "validation") {
                    concatFiles(schemaFile, file)
                }
            } else {
                println("Appending file $file")
                schemaFile.appendText(getFileText(file))
            }
        }
    }

    private fun getFileText(file: File): String {
        val text = file.readText()
        return if (remTodo!!) {
            text.replace(Regex("#<todo>.*?#<\\/todo>", RegexOption.DOT_MATCHES_ALL), "")
        } else {
            text
        }
    }
}

tasks.register<CompileGraphQLSchema>("gqlSchema") {
    dir.set(File(projectDir, "src/main/resources"))
    appName = rootProject.name
    appVer = appVersion
    createdAt = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME)
}
